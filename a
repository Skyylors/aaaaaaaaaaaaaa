#!/usr/bin/env python3
import requests
import time
from stem import Signal
from stem.control import Controller
from datetime import datetime

# ===== √Ä MODIFIER ICI =====
URL = "https://VOTRE_LIEN_ICI"  # ‚ö†Ô∏è METTEZ LE VRAI LIEN
MAX_CLICS = 100  # Nombre de clics souhait√©s
PAUSE = 2  # Secondes entre chaque clic

# Configuration Tor
TOR_PROXY = {
    'http': 'socks5://127.0.0.1:9050',
    'https': 'socks5://127.0.0.1:9050'
}

def get_ip():
    """R√©cup√®re l'IP actuelle"""
    try:
        r = requests.get('http://httpbin.org/ip', proxies=TOR_PROXY, timeout=10)
        return r.json()['origin']
    except:
        return "Erreur"

def renew_ip():
    """Change l'IP Tor"""
    try:
        with Controller.from_port(port=9051) as controller:
            controller.authenticate()
            controller.signal(Signal.NEWNYM)
            time.sleep(3)
        return True
    except:
        return False

def faire_clic():
    """Fait un clic sur l'URL"""
    try:
        r = requests.get(URL, proxies=TOR_PROXY, timeout=15)
        return r.status_code == 200
    except:
        return False

# ===== PROGRAMME PRINCIPAL =====
print("=" * 60)
print("üßÖ SCRIPT DE CLICS AUTOMATIQUES AVEC TOR")
print("=" * 60)

# V√©rification de l'URL
if "VOTRE_LIEN_ICI" in URL:
    print("\n‚ùå ERREUR: Vous devez modifier l'URL dans le script!")
    print("   Ouvrez le script et changez la ligne URL")
    exit(1)

# V√©rification Tor
print("\nüîç V√©rification de Tor...", end=" ")
ip = get_ip()
if ip == "Erreur":
    print("‚ùå")
    print("\n‚ö†Ô∏è Tor ne fonctionne pas!")
    print("Tapez: sudo systemctl start tor")
    exit(1)
else:
    print(f"‚úÖ")
    print(f"   Votre IP Tor: {ip}")

# Test rotation
print("üîÑ Test de rotation d'IP...", end=" ")
if renew_ip():
    nouvelle_ip = get_ip()
    print(f"‚úÖ")
    print(f"   Nouvelle IP: {nouvelle_ip}")
else:
    print("‚ö†Ô∏è (pas grave, on continue)")

print("\n" + "=" * 60)
print(f"üéØ Objectif: {MAX_CLICS} clics")
print(f"üåê URL: {URL}")
print(f"‚è±Ô∏è  Pause: {PAUSE} secondes entre chaque clic")
print("=" * 60)

input("\n‚ñ∂Ô∏è  Appuyez sur ENTR√âE pour d√©marrer...")

# Compteurs
succes = 0
echecs = 0
ips_utilisees = set()
debut = datetime.now()

print("\nüöÄ D√©marrage des clics...\n")

# Boucle principale
for i in range(1, MAX_CLICS * 3):  # Maximum 3x plus de tentatives
    if succes >= MAX_CLICS:
        print(f"\n‚úÖ Objectif atteint: {MAX_CLICS} clics!")
        break
    
    # Obtenir l'IP actuelle
    ip_actuelle = get_ip()
    ips_utilisees.add(ip_actuelle)
    
    # Afficher le clic
    print(f"[{succes}/{MAX_CLICS}] Clic #{i} (IP: {ip_actuelle[:15]})...", end=" ")
    
    # Faire le clic
    if faire_clic():
        succes += 1
        print(f"‚úÖ Total: {succes}")
    else:
        echecs += 1
        print("‚ùå √âchec")
    
    # Si objectif pas atteint, changer d'IP
    if succes < MAX_CLICS:
        renew_ip()
        time.sleep(PAUSE)

# Calcul de la dur√©e
duree = int((datetime.now() - debut).total_seconds())

# R√©sultats finaux
print("\n" + "=" * 60)
print("üìä R√âSULTATS FINAUX")
print("=" * 60)
print(f"‚úÖ Clics r√©ussis     : {succes}")
print(f"‚ùå √âchecs            : {echecs}")
print(f"üåê IPs uniques       : {len(ips_utilisees)}")
print(f"‚è±Ô∏è  Dur√©e totale      : {duree // 60}m {duree % 60}s")
print("=" * 60)

if succes >= MAX_CLICS:
    print("\nüéâ MISSION ACCOMPLIE ! üéâ")
else:
    print(f"\n‚ö†Ô∏è Seulement {succes}/{MAX_CLICS} clics r√©ussis")

print(f"\nüìã Liste des IPs utilis√©es ({len(ips_utilisees)}):")
for idx, ip in enumerate(sorted(ips_utilisees)[:10], 1):
    print(f"   {idx}. {ip}")
if len(ips_utilisees) > 10:
    print(f"   ... et {len(ips_utilisees) - 10} autres")

print("\n" + "=" * 60)
